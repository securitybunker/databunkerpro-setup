# Default values for databunkerpro
replicaCount: 1

image:
  repository: securitybunker/databunkerpro
  tag: latest
  #pullPolicy: IfNotPresent
  pullPolicy: Always

nameOverride: ""
fullnameOverride: "databunkerpro"

serviceAccount:
  create: false  # Disabled by default
  name: ""
  annotations: {}

podAnnotations: {}

podSecurityContext: {}

securityContext: {}

service:
  type: ClusterIP
  port: 3000

ingress:
  enabled: false  # Set to true to enable ingress
  className: nginx
  # Set host to enable ingress
  # host: chart-example.local
  annotations:
    kubernetes.io/ingress.class: nginx
    # For cert-manager automatic certificate generation
    cert-manager.io/cluster-issuer: "letsencrypt-prod"  # or your cluster issuer
    # Alternative: use cert-manager.io/issuer for namespace-scoped issuer
    # cert-manager.io/issuer: "letsencrypt-prod"
    # SSL/TLS specific annotations
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/ssl-passthrough: "false"
    # Security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
      add_header X-Frame-Options DENY always;
      add_header X-Content-Type-Options nosniff always;
      add_header X-XSS-Protection "1; mode=block" always;
  # TLS configuration
  tls:
    enabled: false  # Set to true to enable TLS
    secretName: ""  # Name of the secret containing TLS certificate
    # Alternative: Let cert-manager create the secret automatically
    # secretName: "{{ .Release.Name }}-tls"
    # For multiple hosts
    # - hosts:
    #     - host1.example.com
    #     - host2.example.com
    #   secretName: host1-host2-tls

# SSL Configuration for application-level SSL termination
ssl:
  enabled: false  # Set to true to enable application-level SSL
  # Certificate configuration
  certificate:
    # Use existing secret
    secretName: ""  # Name of existing TLS secret
    # Or let cert-manager create one
    # secretName: "{{ .Release.Name }}-tls"
    # Certificate file paths in the secret
    certFile: "tls.crt"
    keyFile: "tls.key"
    
    # Self-signed certificate generation (when secretName is not provided)
  generateSelfSigned:
    enabled: false  # Set to true to generate self-signed certificates
    duration: 365  # Certificate validity in days
    commonName: "databunkerpro.local"  # Common name for the certificate
    organization: "DataBunkerPro"  # Organization name
    country: "US"  # Country code
    state: "CA"  # State/Province
    locality: "San Francisco"  # City/Locality
    keySize: 2048  # RSA key size in bits
    algorithm: "sha256"  # Hash algorithm
  
  # Service configuration for SSL
  service:
    # Redirect HTTP to HTTPS
    redirectHttp: true

resources: {}

# Database configuration
database:
  # Set to true to use external database (RDS, etc.)
  external: false
  
  # Database type (postgresql or mysql)
  type: postgresql
  
  # External database configuration
  externalConfig:
    host: ""
    port: 5432
    name: "databunkerdb"
    user: "bunkeruser"
    password: ""
    # ssl mode for external postgresql database: require, verify-ca, verify-full, disable
    # ssl mode for external mysql database: true, false, skip-verify, preferred
    sslMode: "require"
  
  # Internal database configuration (used when external: false)
  internal:
    postgresql:
      enabled: true
      # ssl mode for postgresql: require, verify-ca, verify-full, disable
      sslMode: "require"
      image:
        repository: postgres
        tag: "14"
      persistence:
        enabled: true
        size: 8Gi
      resources:
        requests:
          memory: "256Mi"
          cpu: "250m"
        limits:
          memory: "512Mi"
          cpu: "500m"
      auth:
        database: databunkerdb
        username: bunkeruser
        password: ""  # Will be auto-generated if not set
      # SSL configuration
      ssl:
        enabled: true
        duration: 3650 # ssl certificate duration in days
        mode: "require"
        # For production, you should provide your own certificates
        # For development/testing, PostgreSQL will generate self-signed certificates
        generateSelfSigned: true
        # External certificate configuration (when generateSelfSigned: false)
        secretName: ""  # Name of the secret containing server.crt and server.key

    mysql:
      enabled: false
      # ssl mode for mysql: true, false, skip-verify, preferred
      sslMode: "skip-verify"
      image:
        repository: percona
        tag: "8"
      persistence:
        enabled: true
        size: 8Gi
      resources:
        requests:
          memory: "2Gi"
          cpu: "500m"
        limits:
          memory: "4Gi"
          cpu: "1"
      args:
        - "--bind-address=0.0.0.0"
        - "--max_connections=256"
        - "--innodb_buffer_pool_size=3G"
        - "--innodb_log_file_size=256M"
        - "--innodb_log_buffer_size=16M"
        - "--innodb_flush_log_at_trx_commit=1"
        - "--innodb_flush_method=O_DIRECT"
        - "--innodb_file_per_table=1"
      #  - "--innodb_file_format=Barracuda"
      auth:
        database: databunkerdb
        username: bunkeruser
        password: ""  # Will be auto-generated if not set
        rootPassword: ""  # Will be auto-generated if not set

# Redis configuration
redis:
  enabled: true
  image:
    repository: redis
    tag: "7"
  persistence:
    enabled: false
    size: 8Gi
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "1Gi"
      cpu: "200m"
  auth:
    password: ""  # Will be auto-generated if not set

# DatabunkerPro configuration
config:
  # Wrapping key for encryption
  wrappingKey: ""  # Will be auto-generated if not set
  
  # DatabunkerPro configuration
  databunker:
    # Default configuration that will be mounted as databunker.yaml
    # Users can override this in their values
    port: 3000
    logLevel: info
